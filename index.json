[{"content":"What is Array?  Array is a collection of elements stored in contiguous memory. Array is fixed size. Once the size is given to it, it cannot be changed. Elements must be same type.  Initialize Array package main  import \u0026#34;fmt\u0026#34;  func main() { \tvar s [4]int // initialize int type array with length 4.  \tfmt.Println(s) // [0 0 0 0] } You can define length of array like [4].\nLength of array is defined at compile time. So it cannot be changed.\nMemory Alignment package main  import ( \t\u0026#34;fmt\u0026#34; \t\u0026#34;unsafe\u0026#34; )  func main() { \ts := [4]int{10, 20, 30, 40} \tfmt.Printf(\u0026#34;%p, %p, %p, %p\\n\u0026#34;, \u0026amp;s[0], \u0026amp;s[1], \u0026amp;s[2], \u0026amp;s[3]) // 0xc000102000, 0xc000102008, 0xc000102010, 0xc000102018 \tfmt.Println(unsafe.Sizeof(s)) // total size is 8 x 4 = 32 bytes } Array is contiguous memory.\nEach element in array s is int. Int is 8 bytes in 64 bits architecture.\nCalculate the position of each element by simply adding an offset to a base value.\nYou can see address of elements are increasing by 8.\nAccess Array by Index package main  import ( \t\u0026#34;fmt\u0026#34; )  func main() { \ts := [4]int{10, 20, 30, 40} \tfmt.Println(s[0]) // 10 } Array has advantage in random access. It uses index to access the specific element.\nNo matter how long the array is, if you use index, it always costs O(1).\nArray has good cache locality too.\nSince it is stored in contiguous memory, there is less chance of cache miss.\nBut since it has fixed size, it is a bit inflexible, so array is not often seen in Go code.\nHowever, we see slices everywhere.\nWhat is Slice?  Slice is a dynamic array. Unlike array, slice\u0026rsquo;s size can be changed during runtime.  Initialize Slice package main  import ( \t\u0026#34;fmt\u0026#34; )  func main() { \ts := []int{10, 20, 30, 40} // method one \tt := make([]int, 5) // method two \tfmt.Println(s) // [10 20 30 40] \tfmt.Println(t) // [0 0 0 0 0] } There are two ways to initialize slice.\nOne is same as initializing array, but without any length. Like []T\nSecond is by using built-in function called \u0026ldquo;make\u0026rdquo;.\nfunc make([]T, len, cap) []T\nmake function takes a type, a length, and an optional capacity.\nAccess Slice by Index package main  import ( \t\u0026#34;fmt\u0026#34; )  func main() { \ts := []int{10, 20, 30, 40} \tfmt.Println(s[0]) // 10 } Slice just works like array.\nBecause\u0026hellip;\nSlice Internal \nSlice is just data structure that points to its underlying array.\nIt consists of a pointer to the array, the length of the slice, and capacity.\n\npackage main  import \u0026#34;fmt\u0026#34;  func main() { \ts := make([]byte, 5) \tfmt.Println(s) // [0 0 0 0 0] } This is how slice of bytes looks like under layer.\nSlice pointer is pointing to its underlying array.\nSlice has length of 5 and capacity of 5.\nSlice Append package main  import \u0026#34;fmt\u0026#34;  func main() { \ts := make([]int, 5) \tt := make([]int, 5, 6)  \tfmt.Println(len(s), cap(s)) // 5 5 \tfmt.Println(len(t), cap(t)) // 5 6  \tfmt.Printf(\u0026#34;%p\\n\u0026#34;, s) // 0xc00018a000 \tfmt.Printf(\u0026#34;%p\\n\u0026#34;, t) // 0xc00018a030  \t// append data  \ts = append(s, 1) \tt = append(t, 1)  \tfmt.Println(len(s), cap(s)) // 6 10 \tfmt.Println(len(t), cap(t)) // 6 6  \tfmt.Printf(\u0026#34;%p\\n\u0026#34;, s) // 0xc000194000 \tfmt.Printf(\u0026#34;%p\\n\u0026#34;, t) // 0xc00018a030 } When adding element to the back of slice, if slice has free capacity, then it costs O(1).\nYou just have to push into the free space.\nHowever if capacity does not have any free space, then the magic happens.\nSlice copies its underlying array then make another new array with bigger size. (usually doubles)\nThen paste old data into new array and points to it.\nThis costs O(N) because you have to copy N times.\npackage main  import \u0026#34;fmt\u0026#34;  func main() { \ts := make([]int, 5) \tt := make([]int, 5, 10)  \tfmt.Println(len(s), cap(s)) // 5 5 \tfmt.Println(len(t), cap(t)) // 5 10  \tfmt.Printf(\u0026#34;%p\\n\u0026#34;, s) // 0xc00018a000 \tfmt.Printf(\u0026#34;%p\\n\u0026#34;, t) // 0xc00018a030  \t// append data  \ts = append(s[:4], s[3:]...) // append to make replace spot \tt = append(t[:4], t[3:]...) // append to make replace spot \ts[3] = 100 \tt[3] = 100  \tfmt.Println(len(s), cap(s)) // 6 10 \tfmt.Println(len(t), cap(t)) // 6 10  \tfmt.Printf(\u0026#34;%p\\n\u0026#34;, s) // 0xc000194000 \tfmt.Printf(\u0026#34;%p\\n\u0026#34;, t) // 0xc00018a030  \tfmt.Println(s) // [0 0 0 100 0 0] \tfmt.Println(t) // [0 0 0 100 0 0] } Now let\u0026rsquo;s try to add to the middle.\nIt looks same as appending to last. But it\u0026rsquo;s not.\nEven though you have enough capacity and did not make new underlying array, you appended to make replace spot.\nSo it is O(N).\nSlice Remove package main  import \u0026#34;fmt\u0026#34;  func main() { \ts := []int{1,2,3,4,5}  \ts = append(s[:2], s[3:]...) // append to delete index 2  \tfmt.Println(s) // [1 2 4 5] } When removing, element from first and last index is O(1).\nBecause you just move around length pointer.\nBut removing element in the middle is O(N).\nReferences  https://go.dev/blog/slices-intro https://en.wikipedia.org/wiki/Locality_of_reference https://www.geeksforgeeks.org/introduction-to-arrays  ","permalink":"https://go-qkbell.github.io/posts/data_structure/array_slice/","summary":"What are array and slice","title":"[DataStructure] Array \u0026 Slice"},{"content":"내가 공부할 때 사용하는 자료들 KR  https://ultimate-go-korean.gitbook.io/book/ https://miryang.gitbook.io/learn-go-with-tests/ http://pyrasis.com/go.html https://www.youtube.com/c/TuckerProgramming  EN  https://research.swtch.com/ https://go101.org/article/101.html https://github.com/golang/go/wiki/CommonMistakes https://github.com/uber-go/guide/blob/master/style.md https://go.dev/tour/welcome/1 https://www.reddit.com/r/golang/ https://www.youtube.com/c/JunminLee  ","permalink":"https://go-qkbell.github.io/posts/study/go_study/","summary":"Go 한국어 자료 모음","title":"[Study] Go 한국어 자료 모음"},{"content":"Why I started I usually search in google or stackoverflow when I\u0026rsquo;m stuck while coding.\nSometimes their answers lead me to third-party blogs.\nWhen I find informative answers I really thank the author.\nAlso, they really motivate me to write posts like them.\nI\u0026rsquo;m not a perfect programmer, but I think it will be great if I can share my knowledge and experience with others and get some feedbacks.\nWhat Contents? I will be posting about things I\u0026rsquo;ve studied, experienced and how I solved them. ✍\nWhen to post? I will be posting once a week.\n","permalink":"https://go-qkbell.github.io/posts/blog/first/","summary":"I\u0026rsquo;m starting my Devlog","title":"[README] Starting Devlog"}]