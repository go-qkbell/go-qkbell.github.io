[{"content":"What is Linked List?  Linked list is a linear collection of data. Linked List is NOT stored in physically contiguous memory. Linked List\u0026rsquo;s length can be increased/decreased in run time. Instead, Linked list has node that points to the next.  Implement Linked List package main  import ( \t\u0026#34;fmt\u0026#34; )  type SinglyLinkedList struct { \thead *SinglyNode \ttail *SinglyNode \tlength int }  type SinglyNode struct { \tnext *SinglyNode \tvalue int }  func NewSinglyList() *SinglyLinkedList { \treturn \u0026amp;SinglyLinkedList{ \thead: nil, \ttail: nil, \tlength: 0, \t} }  func NewSinglyNode(v int) *SinglyNode { \treturn \u0026amp;SinglyNode{ \tnext: nil, \tvalue: v, \t} }  func main() { \tnewList := NewSinglyList() \tfmt.Println(newList) // \u0026amp;{\u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; 0} } Linked list has head and tail, which is node.\nNode consist of its own value and address of next node.\nAdd Node to Linked List func (s *SinglyLinkedList) AddFront(n *SinglyNode) { \tif s.head == nil { \ts.head = n \ts.tail = n \t} else { \tn.next = s.head \ts.head = n \t}  \ts.length++ }  func (s *SinglyLinkedList) AddBack(n *SinglyNode) { \tif s.tail == nil { \ts.head = n \ts.tail = n \t} else { \ts.tail.next = n \ts.tail = n \t}  \ts.length++ }  func (s *SinglyLinkedList) AddAt(n *SinglyNode, idx int) { \tif idx == 0 { \ts.AddFront(n) \treturn \t} else if idx \u0026gt; s.length { \ts.AddBack(n) \treturn \t} else { \tnode := s.head \tfor i := 0; i \u0026lt; idx-1; i++ { \tnode = node.next \t} \tn.next = node.next \tnode.next = n \t}  \ts.length++ } Adding in the front or back of the linked list costs O(1).\nBecause all you have to do is make node and let linked list\u0026rsquo;s head or tail point to it, and change links between nodes.\nHowever, adding in the given index is O(N), because you have to traverse until the index.\nRemember how array and slice can access index in O(1)?\nBecause their memories are physically contiguous.\nBut since linked list memory is not physically contiguous, you have to follow along by nodes\u0026rsquo; next address.\nDelete Node in Linked List func (s *SinglyLinkedList) RemoveFront() { \tif s.head == nil { \treturn \t} \tif s.head == s.tail { \ts.head = nil \ts.tail = nil \t} else { \ts.head = s.head.next \t}  \ts.length-- }  func (s *SinglyLinkedList) RemoveBack() { \tif s.tail == nil { \treturn \t} \tif s.head == s.tail { \ts.head = nil \ts.tail = nil \t} else { \tfor n := s.head; n != nil; { \tif n.next == s.tail { \ts.tail = n \tn.next = nil \t} \tn = n.next \t} \t}  \ts.length-- }  func (s *SinglyLinkedList) RemoveNode(n *SinglyNode) { \tif s.head == n { \ts.head = s.head.next \ts.length-- \treturn \t}  \tfor pn := s.head; pn != nil; { \tif pn.next == n { \tpn.next = n.next  \tif n == s.tail { \ts.tail = pn \t}  \tbreak \t}  \tpn = pn.next \t}  \ts.length-- } Deleting front node of the linked list costs O(1).\nHowever deleting node at the back costs O(N).\nBecause since you don\u0026rsquo;t know tail\u0026rsquo;s previous node, you have to traverse all the way to tail node\u0026rsquo;s previous node.\nDeleting specific node costs O(N). You don\u0026rsquo;t know node\u0026rsquo;s previous node, so you have to traverse to find previous node.\n","permalink":"https://go-qkbell.github.io/posts/data_structure/linked_list/","summary":"What is linked list","title":"[DataStructure] Linked List"},{"content":"What is Array?  Array is a collection of data stored in physically contiguous memory. Array is fixed size. Once the size is given to it, it cannot be changed. Elements must be same type.  Initialize Array package main  import \u0026#34;fmt\u0026#34;  func main() { \tvar s [4]int // initialize int type array with length 4.  \tfmt.Println(s) // [0 0 0 0] } You can define length of array like [4]T.\nLength of array is defined at compile time. So it cannot be changed.\nMemory Alignment package main  import ( \t\u0026#34;fmt\u0026#34; \t\u0026#34;unsafe\u0026#34; )  func main() { \ts := [4]int{10, 20, 30, 40} \tfmt.Printf(\u0026#34;%p, %p, %p, %p\\n\u0026#34;, \u0026amp;s[0], \u0026amp;s[1], \u0026amp;s[2], \u0026amp;s[3]) // 0xc000102000, 0xc000102008, 0xc000102010, 0xc000102018 \tfmt.Println(unsafe.Sizeof(s)) // total size is 8 x 4 = 32 bytes } Array is contiguous memory.\nEach element in array s is int. Int is 8 bytes in 64 bits architecture.\nCalculate the position of each element by simply adding an offset to a base value.\nYou can see address of elements are increasing by 8.\nAccess Array by Index package main  import ( \t\u0026#34;fmt\u0026#34; )  func main() { \ts := [4]int{10, 20, 30, 40} \tfmt.Println(s[0]) // 10 } Array has advantage in random access. It uses index to access the specific element.\nNo matter how long the array is, if you use index, it always costs O(1).\nArray has good cache locality too.\nSince it is stored in contiguous memory, there is less chance of cache miss.\nBut since it has fixed size, it is a bit inflexible, so array is not often seen in Go code.\nHowever, we see slices everywhere.\nWhat is Slice?  Slice is a dynamic array. Unlike array, slice\u0026rsquo;s size can be changed during runtime.  Initialize Slice package main  import ( \t\u0026#34;fmt\u0026#34; )  func main() { \ts := []int{10, 20, 30, 40} // method one \tt := make([]int, 5) // method two \tfmt.Println(s) // [10 20 30 40] \tfmt.Println(t) // [0 0 0 0 0] } There are two ways to initialize slice.\nOne is same as initializing array, but without any length. Like []T.\nSecond is by using built-in function called \u0026ldquo;make\u0026rdquo;.\nfunc make([]T, len, cap) []T\nmake function takes a type, a length, and an optional capacity.\nAccess Slice by Index package main  import ( \t\u0026#34;fmt\u0026#34; )  func main() { \ts := []int{10, 20, 30, 40} \tfmt.Println(s[0]) // 10 } Slice just works like array.\nBecause\u0026hellip;\nSlice Internal Slice is just data structure that points to its underlying array.\nIt consists of a pointer to the array, the length of the slice, and capacity.\npackage main  import \u0026#34;fmt\u0026#34;  func main() { \ts := make([]byte, 5) \tfmt.Println(s) // [0 0 0 0 0] } This is how slice of bytes looks like under layer.\nSlice pointer is pointing to its underlying array.\nSlice has length of 5 and capacity of 5.\nSlice Append package main  import \u0026#34;fmt\u0026#34;  func main() { \ts := make([]int, 5) \tt := make([]int, 5, 6)  \tfmt.Println(len(s), cap(s)) // 5 5 \tfmt.Println(len(t), cap(t)) // 5 6  \tfmt.Printf(\u0026#34;%p\\n\u0026#34;, s) // 0xc00018a000 \tfmt.Printf(\u0026#34;%p\\n\u0026#34;, t) // 0xc00018a030  \t// append data  \ts = append(s, 1) \tt = append(t, 1)  \tfmt.Println(len(s), cap(s)) // 6 10 \tfmt.Println(len(t), cap(t)) // 6 6  \tfmt.Printf(\u0026#34;%p\\n\u0026#34;, s) // 0xc000194000 \tfmt.Printf(\u0026#34;%p\\n\u0026#34;, t) // 0xc00018a030 } When adding element to the back of slice, if slice has free capacity, then it costs O(1).\nYou just have to push into the free space.\nHowever if capacity does not have any free space, then the magic happens.\nSince array is fixed size and cannot be changed, slice copies its underlying array then make another new array with bigger size. (usually doubles)\nThen paste old data into new array and points to it.\nThis costs O(N) because you have to copy N times.\npackage main  import \u0026#34;fmt\u0026#34;  func main() { \ts := make([]int, 5) \tt := make([]int, 5, 10)  \tfmt.Println(len(s), cap(s)) // 5 5 \tfmt.Println(len(t), cap(t)) // 5 10  \tfmt.Printf(\u0026#34;%p\\n\u0026#34;, s) // 0xc00018a000 \tfmt.Printf(\u0026#34;%p\\n\u0026#34;, t) // 0xc00018a030  \t// append data  \ts = append(s[:4], s[3:]...) // append to make replace spot \tt = append(t[:4], t[3:]...) // append to make replace spot \ts[3] = 100 // change \tt[3] = 100 // change  \tfmt.Println(len(s), cap(s)) // 6 10 \tfmt.Println(len(t), cap(t)) // 6 10  \tfmt.Printf(\u0026#34;%p\\n\u0026#34;, s) // 0xc000194000 \tfmt.Printf(\u0026#34;%p\\n\u0026#34;, t) // 0xc00018a030  \tfmt.Println(s) // [0 0 0 100 0 0] \tfmt.Println(t) // [0 0 0 100 0 0] } Now let\u0026rsquo;s try to add to the middle.\nIt looks same as appending to last. But it\u0026rsquo;s not.\nEven though you have enough capacity and did not make new underlying array, you appended to make replace spot.\nSo it is O(N).\nSlice Remove package main  import \u0026#34;fmt\u0026#34;  func main() { \ts := []int{1,2,3,4,5}  \ts = append(s[:2], s[3:]...) // append to delete index 2  \tfmt.Println(s) // [1 2 4 5] } When removing, element from first and last index is O(1).\nBecause you just move around length pointer.\nBut removing element in the middle needs append and costs O(N).\nNil Slice package main  import \u0026#34;fmt\u0026#34;  func main() { \tvar a []int \tvar b []int = make([]int, 0) \tvar c []int = []int{}  \tfmt.Println(a, b, c) // [] [] [] \tfmt.Println(a == nil) // true \tfmt.Println(b == nil) // false \tfmt.Println(c == nil) // false } Nil slice means, slice does not have memory address.\nB and C slices are initialized with 0 length underlying array, and have memory address.\nHowever, A slice is just declared and is not initialized. (A does not have underlying array)\nAll 3 of them have 0 length, but they are not same.\nYou have to be careful dealing with nil slice and empty slice.\nReferences  https://go.dev/blog/slices-intro https://en.wikipedia.org/wiki/Locality_of_reference https://www.geeksforgeeks.org/introduction-to-arrays  ","permalink":"https://go-qkbell.github.io/posts/data_structure/array_slice/","summary":"What are array and slice","title":"[DataStructure] Array \u0026 Slice"},{"content":"내가 공부할 때 사용하는 자료들 KR  https://ultimate-go-korean.gitbook.io/book/ https://miryang.gitbook.io/learn-go-with-tests/ http://pyrasis.com/go.html https://www.youtube.com/c/TuckerProgramming  EN  https://research.swtch.com/ https://go101.org/article/101.html https://github.com/golang/go/wiki/CommonMistakes https://github.com/uber-go/guide/blob/master/style.md https://go.dev/tour/welcome/1 https://www.reddit.com/r/golang/ https://www.youtube.com/c/JunminLee  ","permalink":"https://go-qkbell.github.io/posts/study/go_study/","summary":"Go 한국어 자료 모음","title":"[Study] Go 한국어 자료 모음"},{"content":"Why I started I usually search in google or stackoverflow when I\u0026rsquo;m stuck while coding.\nSometimes their answers lead me to third-party blogs.\nWhen I find informative answers I really thank the author.\nAlso, they motivate me to write posts like them.\nI\u0026rsquo;m not a perfect programmer, but I think it will be great if I can share my knowledge and experience with others and get some feedbacks.\nWhat Contents? I will be posting about things I\u0026rsquo;ve studied, experienced and how I solved them. ✍\nWhen to post? I will be posting once a week.\n","permalink":"https://go-qkbell.github.io/posts/blog/first/","summary":"I\u0026rsquo;m starting my Devlog","title":"[README] Starting Devlog"}]