[{"content":"What is Hash Table?  Key, Value data structure Very fast insert, delete, and search O(1) Using hash function to choose bucket index  Internally hash table uses array(bucket). Remember, array costs O(N) to search.\nBut hash table costs O(1). How does that work?\nIt\u0026rsquo;s because hash table uses hash function to determine which index is to be used.\nWhat is Hash Function?  Hash Function transforms data into fixed length Hash Function always gives same output for same input  When you put key into hash function, it outputs hash code, and you can use it for index.\nInstead of iterating the whole array, you just have to look up the index(hash code).\nHash Function is a key role in hash table.\nGood hash function must be fast, efficient, and outputs unique hash code.\nThis looks like the best data structure.\nIs hash table perfect?\nUnfortunately it\u0026rsquo;s not. Because eventually, there is going to be a hash collision.\nWhat is Hash Collision? Hash collision is when more than two keys share the same hash code.\nThis happens because hash function gets us a small number for a key which is a big integer or string or etc.\nEven though hash algorithms have been created with the intent of being collision resistant, it\u0026rsquo;s still not perfect.\nThis will be a conflict when there are lots of hash collisions and many data gets stored in particular bucket.\nCollision Resolution Method Open Addressing Open addressing is one of the collision resolution method.\nOpen address uses empty space in the bucket.\nLinear Probing\n linearly move N times until you find empty slot and store there.\n  Quadratic Probing\n linearly move N^2 times until you find empty slot and store there.\n  Problem of open addressing\n  Size of bucket\n\u0026ndash; Size of bucket must be same or greater than keys to store all the keys.\n  Data clustering\n\u0026ndash; Many data form groups in bucket, and it will start to take time to find a free slot or to search for an index.\n\u0026ndash; Need to re-hash hash table when elements are deleted.\n  Separate Chaining Separate chaining uses extra memory to store value when collision happens.\nIt creates linked list at bucket and keep adding value at tail when collision occurs.\nThis is simple to implement and bucket array never fills up, but if the chain becomes long, search time will be O(N) because it\u0026rsquo;s a linked list. I will use separate chaining in below hash table implement\nImplement Hash Table package main  import \u0026#34;fmt\u0026#34;  const ArraySize = 7  type HashTable struct { \tarray [ArraySize]*bucket }  type bucket struct { \thead *bucketNode }  type bucketNode struct { \tkey string \tnext *bucketNode }  func (h *HashTable) Insert(key string) { \tindex := hash(key) \th.array[index].insert(key) }  func (h *HashTable) Search(key string) bool { \tindex := hash(key) \treturn h.array[index].search(key) }  func (h *HashTable) Delete(key string) { \tindex := hash(key) \th.array[index].delete(key) }  func (b *bucket) insert(k string) { \tif !b.search(k) { \tnewNode := \u0026amp;bucketNode{key: k} \tnewNode.next = b.head \tb.head = newNode \t} else { \tfmt.Println(\u0026#34;Already Exists\u0026#34;) \t}  }  func (b *bucket) search(k string) bool { \tcurrentNode := b.head \tfor currentNode != nil { \tif currentNode.key == k { \treturn true \t} \tcurrentNode = currentNode.next \t}  \treturn false }  func (b *bucket) delete(k string) { \tif b.head.key == k { \tb.head = b.head.next \t} else { \tprevNode := b.head \tfor prevNode.next != nil { \tif prevNode.next.key == k { \tprevNode.next = prevNode.next.next \t} \tprevNode = prevNode.next \t} \t} }  func hash(key string) int { \tsum := 0 \tfor _, v := range key { \tsum += int(v) \t}  \treturn sum % ArraySize } Hash Table Time Complexity  Insert: O(1) Remove: O(1) Search: O(1)  BUT hash function and collision really matters in time complexity when using hash table.\nSo it is very important to implement efficient hash function.\n","permalink":"https://go-qkbell.github.io/posts/data_structure/hash_table/","summary":"What is Hash Table","title":"[DataStructure] Hash Table"},{"content":"What is Doubly Linked List?  Doubly Linked List is just like Singly Linked List, but with previous node.  Implement Doubly Linked List package main  type DoublyLinkedList struct { \thead *DoublyNode \ttail *DoublyNode \tlength int }  type DoublyNode struct { \tnext *DoublyNode \tprev *DoublyNode \tvalue int }  func NewDoublyList() *DoublyLinkedList { \treturn \u0026amp;DoublyLinkedList{ \thead: nil, \ttail: nil, \tlength: 0, \t} }  func NewDoublyNode(v int) *DoublyNode { \treturn \u0026amp;DoublyNode{ \tnext: nil, \tprev: nil, \tvalue: v, \t} } Doubly Linked List has extra node that points to previous node\u0026rsquo;s address.\nAdd Node to Doubly Linked List func (s *DoublyLinkedList) AddFront(n *DoublyNode) { \tif s.head == nil { \ts.head = n \ts.tail = n \t} else { \tn.next = s.head \ts.head.prev = n \ts.head = n \t}  \ts.length++ }  func (s *DoublyLinkedList) AddBack(n *DoublyNode) { \tif s.tail == nil { \ts.head = n \ts.tail = n \t} else { \tn.prev = s.tail \ts.tail.next = n \ts.tail = n \t}  \ts.length++ }  func (s *DoublyLinkedList) AddAt(n *DoublyNode, idx int) { \tif idx == 0 { \ts.AddFront(n) \treturn \t} else if idx \u0026gt; s.length { \ts.AddBack(n) \treturn \t} else { \tnode := s.head \tfor i := 0; i \u0026lt; idx-1; i++ { \tnode = node.next \t} \tn.next = node.next \tn.prev = node \tnode.next.prev = n \tnode.next = n  \t}  \ts.length++ } Delete Node in Singly Linked List func (s *DoublyLinkedList) RemoveFront() { \tif s.head == nil { \treturn \t} \tif s.head == s.tail { \ts.head = nil \ts.tail = nil \t} else { \ts.head = s.head.next \ts.head.prev = nil \t}  \ts.length-- }  func (s *DoublyLinkedList) RemoveBack() { \tif s.tail == nil { \treturn \t} \tif s.head == s.tail { \ts.head = nil \ts.tail = nil \t} else { \ts.tail = s.tail.prev \ts.tail.next = nil \t}  \ts.length-- }  func (s *DoublyLinkedList) RemoveNode(n *DoublyNode) { \tif s.head == n { \ts.RemoveFront() \treturn \t} \tif n == s.tail { \ts.RemoveBack() \treturn \t}  \tpn := n.prev  \tpn.next = pn.next.next \tpn.next.prev = pn  \ts.length-- } Singly Linked List costs O(N) when removing tail node.\nBecause Singly Linked List does not know where tail node\u0026rsquo;s previous node is.\nHowever Doubly Linked List has information about previous node. So it just costs O(1). You just have to set Doubly Linked List\u0026rsquo;s tail to current tail node\u0026rsquo;s previous node.\nDoubly Linked List Time Complexity  Insert at head: O(1) Insert at tail: O(1) Insert at index: O(N) Remove at head: O(1) Remove at tail: O(1) Remove at index: O(N) Access Index: O(N) Search: O(N)  ","permalink":"https://go-qkbell.github.io/posts/data_structure/doubly_linked_list/","summary":"What is doubly linked list","title":"[DataStructure] Doubly Linked List"},{"content":"What is Singly Linked List?  Linked list is a linear collection of data. Linked List is NOT stored in physically contiguous memory. Linked List\u0026rsquo;s length can be increased/decreased in runtime. Instead, Linked list contains node that points to the next.  Implement Singly Linked List package main  import ( \t\u0026#34;fmt\u0026#34; )  type SinglyLinkedList struct { \thead *SinglyNode \ttail *SinglyNode \tlength int }  type SinglyNode struct { \tnext *SinglyNode \tvalue int }  func NewSinglyList() *SinglyLinkedList { \treturn \u0026amp;SinglyLinkedList{ \thead: nil, \ttail: nil, \tlength: 0, \t} }  func NewSinglyNode(v int) *SinglyNode { \treturn \u0026amp;SinglyNode{ \tnext: nil, \tvalue: v, \t} }  func main() { \tnewList := NewSinglyList() \tfmt.Println(newList) // \u0026amp;{\u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; 0} } Linked list has head and tail, which is node\u0026rsquo;s address.\nNode consist of its own value and address to the next node.\nAdd Node to Singly Linked List func (s *SinglyLinkedList) AddFront(n *SinglyNode) { \tif s.head == nil { \ts.head = n \ts.tail = n \t} else { \tn.next = s.head \ts.head = n \t}  \ts.length++ }  func (s *SinglyLinkedList) AddBack(n *SinglyNode) { \tif s.tail == nil { \ts.head = n \ts.tail = n \t} else { \ts.tail.next = n \ts.tail = n \t}  \ts.length++ }  func (s *SinglyLinkedList) AddAt(n *SinglyNode, idx int) { \tif idx == 0 { \ts.AddFront(n) \treturn \t} else if idx \u0026gt; s.length { \ts.AddBack(n) \treturn \t} else { \tnode := s.head \tfor i := 0; i \u0026lt; idx-1; i++ { \tnode = node.next \t} \tn.next = node.next \tnode.next = n \t}  \ts.length++ } Adding at the back of the linked list costs O(1).\nBecause all you have to do is make linked list\u0026rsquo;s current tail node\u0026rsquo;s next to point to the new node.\nThen change linked list\u0026rsquo;s tail to the new node.\nAdding at the front also costs O(1).\nBecause all you have to do is make new node that points to linked list\u0026rsquo;s current head node.\nThen change linked list\u0026rsquo;s head to the new node.\nHowever, adding at the given index is O(N), because you have to traverse until the index.\nRemember how array and slice can access index O(1)?\nBecause array and slice\u0026rsquo;s memory is physically contiguous.\nBut since linked list\u0026rsquo;s memory is not physically contiguous, you have to traverse all the way by following nodes\u0026rsquo; next addresses.\nDelete Node in Singly Linked List func (s *SinglyLinkedList) RemoveFront() { \tif s.head == nil { \treturn \t} \tif s.head == s.tail { \ts.head = nil \ts.tail = nil \t} else { \ts.head = s.head.next \t}  \ts.length-- }  func (s *SinglyLinkedList) RemoveBack() { \tif s.tail == nil { \treturn \t} \tif s.head == s.tail { \ts.head = nil \ts.tail = nil \t} else { \tfor n := s.head; n != nil; { \tif n.next == s.tail { \ts.tail = n \tn.next = nil \t} \tn = n.next \t} \t}  \ts.length-- }  func (s *SinglyLinkedList) RemoveNode(n *SinglyNode) { \tif s.head == n { \ts.head = s.head.next \ts.length-- \treturn \t}  \tfor pn := s.head; pn != nil; { \tif pn.next == n { \tpn.next = n.next  \tif n == s.tail { \ts.tail = pn \t}  \tbreak \t}  \tpn = pn.next \t}  \ts.length-- } Deleting front node of the linked list costs O(1).\nJust set your head node to current head node\u0026rsquo;s next node.\nHowever deleting node at the back costs O(N).\nBecause you don\u0026rsquo;t know current tail node\u0026rsquo;s previous node. (which is going to be a new tail node)\nYou have to traverse all the way to tail node\u0026rsquo;s previous node.\nThen delete tail node and set tail node\u0026rsquo;s previous node to tail. Deleting specific node also costs O(N). You don\u0026rsquo;t know node\u0026rsquo;s previous node, so you have to traverse to find previous node.\nSingly Linked List Time Complexity  Insert at head: O(1) Insert at tail: O(1) Insert at index: O(N) Remove at head: O(1) Remove at tail: O(N) Remove at index: O(N) Access Index: O(N) Search: O(N)  There is improved linked list called Doubly Linked List.\nWe will talk about that in the next post.\nReferences  https://www.geeksforgeeks.org/data-structures/linked-list/ https://www.programiz.com/dsa/linked-list  ","permalink":"https://go-qkbell.github.io/posts/data_structure/singly_linked_list/","summary":"What is singly linked list","title":"[DataStructure] Singly Linked List"},{"content":"갑자기 든 생각인데, 취직하고 나서는 개인 프로젝트를 진행한 것도 없고 주말에 한 시간 이상 코딩을 해본적도 없는 것 같다.\n딱히 게임을 많이 하는 것도 아니고, 해봤자 주말에 에이펙스 한두시간 하고 안하는편인데\n왜이럴까 생각해보니, 요즘 버튜버에 빠져 있어서 하루종일 유튜브만 보는 것 같다.\n이왕 보는거 코딩도 하면서 보려고 내가 좋아하는 취미랑 연관도 있고 학습도 할 겸 홀로라이브 디스코드 봇을 제작해보려고 한다.\n현재 생각중인 핵심 기능으로는\n 현재 라이브 방송 중인 모든 홀로라이브 멤버를 알려주는 기능  채널명, 채널 링크, 썸네일 사진, 시청자수   라이브 방송 예정인 홀로라이브 멤버들을 알려주는 기능  채널명, 채널 링크, 썸네일 사진, 시작 예정 시간   홀로라이브 멤버가 새 영상을 유튜브에 올리면 알림 해주는 기능 홀로라이브 멤버 정보를 출력 해주는 기능  이렇게 4 가지가 있다. 나머지는 개발하면서 생각 나면 실시간으로 추가하는걸로.. 필요한 작업 으로는\n 디스코드 연동 유튜브 연동 홀로라이브 데이터 폴링 혹은 pubsub 구독 만약 폴링 구조로 갈 시, 홀로라이브 데이터 일정 시간동안 캐싱  등이 있는 것 같다. 인프라는 구글 클라우드 vm 인스턴스랑 cloud run 중에 고민중이다.\n어차피 이걸로 대형 디스코드 서버를 운영할 생각도 없고, 그냥 개인 서버에서 친구들이랑 쓸 용도라 cloud run 프리티어로 굴리면서 서버리스로 가도 될 것 같은데..\n우선 이부분은 어느정도 개발을 끝마치고 생각해 봐야겠다.\n오랜만에 재밌어보이는 프로젝트라 기대된다.\n","permalink":"https://go-qkbell.github.io/posts/study/hololive1/","summary":"홀로라이브 디스코드 봇 제작기","title":"[Study] Hololive Discord Bot 제작기 #1"},{"content":"What is Array?  Array is a collection of data stored in physically contiguous memory. Array is fixed size. Once the size is given to it, it cannot be changed. Elements must be same type.  Initialize Array package main  import \u0026#34;fmt\u0026#34;  func main() { \tvar s [4]int // initialize int type array with length 4.  \tfmt.Println(s) // [0 0 0 0] } You can define length of array like [4]T.\nLength of array is defined at compile time. So it cannot be changed.\nMemory Alignment package main  import ( \t\u0026#34;fmt\u0026#34; \t\u0026#34;unsafe\u0026#34; )  func main() { \ts := [4]int{10, 20, 30, 40} \tfmt.Printf(\u0026#34;%p, %p, %p, %p\\n\u0026#34;, \u0026amp;s[0], \u0026amp;s[1], \u0026amp;s[2], \u0026amp;s[3]) // 0xc000102000, 0xc000102008, 0xc000102010, 0xc000102018 \tfmt.Println(unsafe.Sizeof(s)) // total size is 8 x 4 = 32 bytes } Array is contiguous memory.\nEach element in array s is int. Int is 8 bytes in 64 bits architecture.\nCalculate the position of each element by simply adding an offset to a base value.\nYou can see address of elements are increasing by 8.\nAccess Array by Index package main  import ( \t\u0026#34;fmt\u0026#34; )  func main() { \ts := [4]int{10, 20, 30, 40} \tfmt.Println(s[0]) // 10 } Array has advantage in random access. It uses index to access the specific element.\nNo matter how long the array is, if you use index, it always costs O(1).\nArray has good cache locality too.\nSince it is stored in contiguous memory, there is less chance of cache miss.\nBut since it has fixed size, it is a bit inflexible, so array is not often seen in Go code.\nHowever, we see slices everywhere.\nWhat is Slice?  Slice is a dynamic array. Unlike array, slice\u0026rsquo;s size can be changed during runtime.  Initialize Slice package main  import ( \t\u0026#34;fmt\u0026#34; )  func main() { \ts := []int{10, 20, 30, 40} // method one \tt := make([]int, 5) // method two \tfmt.Println(s) // [10 20 30 40] \tfmt.Println(t) // [0 0 0 0 0] } There are two ways to initialize slice.\nOne is same as initializing array, but without any length. Like []T.\nSecond is by using built-in function called \u0026ldquo;make\u0026rdquo;.\nfunc make([]T, len, cap) []T\nmake function takes a type, a length, and an optional capacity.\nAccess Slice by Index package main  import ( \t\u0026#34;fmt\u0026#34; )  func main() { \ts := []int{10, 20, 30, 40} \tfmt.Println(s[0]) // 10 } Slice just works like array.\nBecause\u0026hellip;\nSlice Internal Slice is just data structure that points to its underlying array.\nIt consists of a pointer to the array, the length of the slice, and capacity.\npackage main  import \u0026#34;fmt\u0026#34;  func main() { \ts := make([]byte, 5) \tfmt.Println(s) // [0 0 0 0 0] } This is how slice of bytes looks like under layer.\nSlice pointer is pointing to its underlying array.\nSlice has length of 5 and capacity of 5.\nSlice Append package main  import \u0026#34;fmt\u0026#34;  func main() { \ts := make([]int, 5) \tt := make([]int, 5, 6)  \tfmt.Println(len(s), cap(s)) // 5 5 \tfmt.Println(len(t), cap(t)) // 5 6  \tfmt.Printf(\u0026#34;%p\\n\u0026#34;, s) // 0xc00018a000 \tfmt.Printf(\u0026#34;%p\\n\u0026#34;, t) // 0xc00018a030  \t// append data  \ts = append(s, 1) \tt = append(t, 1)  \tfmt.Println(len(s), cap(s)) // 6 10 \tfmt.Println(len(t), cap(t)) // 6 6  \tfmt.Printf(\u0026#34;%p\\n\u0026#34;, s) // 0xc000194000 \tfmt.Printf(\u0026#34;%p\\n\u0026#34;, t) // 0xc00018a030 } When adding element to the back of slice, if slice has free capacity, then it costs O(1).\nYou just have to push into the free space.\nHowever if capacity does not have any free space, then the magic happens.\nSince array is fixed size and cannot be changed, slice copies its underlying array then make another new array with bigger size. (usually doubles)\nThen paste old data into new array and points to it.\nThis costs O(N) because you have to copy N times.\npackage main  import \u0026#34;fmt\u0026#34;  func main() { \ts := make([]int, 5) \tt := make([]int, 5, 10)  \tfmt.Println(len(s), cap(s)) // 5 5 \tfmt.Println(len(t), cap(t)) // 5 10  \tfmt.Printf(\u0026#34;%p\\n\u0026#34;, s) // 0xc00018a000 \tfmt.Printf(\u0026#34;%p\\n\u0026#34;, t) // 0xc00018a030  \t// append data  \ts = append(s[:4], s[3:]...) // append to make replace spot \tt = append(t[:4], t[3:]...) // append to make replace spot \ts[3] = 100 // change \tt[3] = 100 // change  \tfmt.Println(len(s), cap(s)) // 6 10 \tfmt.Println(len(t), cap(t)) // 6 10  \tfmt.Printf(\u0026#34;%p\\n\u0026#34;, s) // 0xc000194000 \tfmt.Printf(\u0026#34;%p\\n\u0026#34;, t) // 0xc00018a030  \tfmt.Println(s) // [0 0 0 100 0 0] \tfmt.Println(t) // [0 0 0 100 0 0] } Now let\u0026rsquo;s try to add to the middle.\nIt looks same as appending to last. But it\u0026rsquo;s not.\nEven though you have enough capacity and did not make new underlying array, you appended to make replace spot.\nSo it is O(N).\nSlice Remove package main  import \u0026#34;fmt\u0026#34;  func main() { \ts := []int{1,2,3,4,5}  \ts = append(s[:2], s[3:]...) // append to delete index 2  \tfmt.Println(s) // [1 2 4 5] } When removing, element from first and last index is O(1).\nBecause you just move around length pointer.\nBut removing element in the middle needs append and costs O(N).\nNil Slice package main  import \u0026#34;fmt\u0026#34;  func main() { \tvar a []int \tvar b []int = make([]int, 0) \tvar c []int = []int{}  \tfmt.Println(a, b, c) // [] [] [] \tfmt.Println(a == nil) // true \tfmt.Println(b == nil) // false \tfmt.Println(c == nil) // false } Nil slice means, slice does not have memory address.\nB and C slices are initialized with 0 length underlying array, and have memory address.\nHowever, A slice is just declared and is not initialized. (A does not have underlying array)\nAll 3 of them have 0 length, but they are not same.\nYou have to be careful dealing with nil slice and empty slice.\nSlice Time Complexity only worst cases\n Insert at head: O(N) Insert at tail: O(N) Insert at index: O(N) Remove at head: O(1) Remove at tail: O(1) Remove at index: O(N) Access Index: O(1) Search: O(N)  References  https://go.dev/blog/slices-intro https://en.wikipedia.org/wiki/Locality_of_reference https://www.geeksforgeeks.org/introduction-to-arrays  ","permalink":"https://go-qkbell.github.io/posts/data_structure/array_slice/","summary":"What are array and slice","title":"[DataStructure] Array \u0026 Slice"},{"content":"내가 공부할 때 사용하는 사이트들 KR  https://ultimate-go-korean.gitbook.io/book/ https://miryang.gitbook.io/learn-go-with-tests/ http://pyrasis.com/go.html  EN  https://research.swtch.com/ https://go101.org/article/101.html https://github.com/golang/go/wiki/CommonMistakes https://github.com/uber-go/guide/blob/master/style.md https://go.dev/tour/welcome/1 https://www.reddit.com/r/golang/  ","permalink":"https://go-qkbell.github.io/posts/study/go_study/","summary":"Go 한국어/영어 자료 모음","title":"[Study] Go 한국어/영어 자료 모음"},{"content":"Why I started I usually search in google or stackoverflow when I\u0026rsquo;m stuck while coding.\nSometimes their answers lead me to third-party blogs.\nWhen I find informative answers I really thank the author.\nAlso, they motivate me to write posts like them.\nI\u0026rsquo;m not a perfect programmer, but I think it will be great if I can share my knowledge and experience with others and get some feedbacks.\nWhat Contents? I will be posting about things I\u0026rsquo;ve studied, experienced and how I solved them. ✍\nWhen to post? I will be posting once a week.\n","permalink":"https://go-qkbell.github.io/posts/blog/first/","summary":"I\u0026rsquo;m starting my Devlog","title":"[README] Starting Devlog"}]