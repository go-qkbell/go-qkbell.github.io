[{"content":"What is Singly Linked List?  Linked list is a linear collection of data. Linked List is NOT stored in physically contiguous memory. Linked List\u0026rsquo;s length can be increased/decreased in runtime. Instead, Linked list contains node that points to the next.  Implement Linked List package main  import ( \t\u0026#34;fmt\u0026#34; )  type SinglyLinkedList struct { \thead *SinglyNode \ttail *SinglyNode \tlength int }  type SinglyNode struct { \tnext *SinglyNode \tvalue int }  func NewSinglyList() *SinglyLinkedList { \treturn \u0026amp;SinglyLinkedList{ \thead: nil, \ttail: nil, \tlength: 0, \t} }  func NewSinglyNode(v int) *SinglyNode { \treturn \u0026amp;SinglyNode{ \tnext: nil, \tvalue: v, \t} }  func main() { \tnewList := NewSinglyList() \tfmt.Println(newList) // \u0026amp;{\u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; 0} } Linked list has head and tail, which is node\u0026rsquo;s address.\nNode consist of its own value and address to the next node.\nAdd Node to Linked List func (s *SinglyLinkedList) AddFront(n *SinglyNode) { \tif s.head == nil { \ts.head = n \ts.tail = n \t} else { \tn.next = s.head \ts.head = n \t}  \ts.length++ }  func (s *SinglyLinkedList) AddBack(n *SinglyNode) { \tif s.tail == nil { \ts.head = n \ts.tail = n \t} else { \ts.tail.next = n \ts.tail = n \t}  \ts.length++ }  func (s *SinglyLinkedList) AddAt(n *SinglyNode, idx int) { \tif idx == 0 { \ts.AddFront(n) \treturn \t} else if idx \u0026gt; s.length { \ts.AddBack(n) \treturn \t} else { \tnode := s.head \tfor i := 0; i \u0026lt; idx-1; i++ { \tnode = node.next \t} \tn.next = node.next \tnode.next = n \t}  \ts.length++ } Adding at the back of the linked list costs O(1).\nBecause all you have to do is make linked list\u0026rsquo;s current tail node to point to the new node.\nThen change linked list\u0026rsquo;s tail to the new node.\nAdding at the front also costs O(1).\nBecause all you have to do is make new node that points to linked list\u0026rsquo;s current head node.\nThen change linked list\u0026rsquo;s head to the new node.\nHowever, adding at the given index is O(N), because you have to traverse until the index.\nRemember how array and slice can access index O(1)?\nBecause array and slice\u0026rsquo;s memory is physically contiguous.\nBut since linked list\u0026rsquo;s memory is not physically contiguous, you have to traverse all the way by following nodes\u0026rsquo; next addresses.\nDelete Node in Linked List func (s *SinglyLinkedList) RemoveFront() { \tif s.head == nil { \treturn \t} \tif s.head == s.tail { \ts.head = nil \ts.tail = nil \t} else { \ts.head = s.head.next \t}  \ts.length-- }  func (s *SinglyLinkedList) RemoveBack() { \tif s.tail == nil { \treturn \t} \tif s.head == s.tail { \ts.head = nil \ts.tail = nil \t} else { \tfor n := s.head; n != nil; { \tif n.next == s.tail { \ts.tail = n \tn.next = nil \t} \tn = n.next \t} \t}  \ts.length-- }  func (s *SinglyLinkedList) RemoveNode(n *SinglyNode) { \tif s.head == n { \ts.head = s.head.next \ts.length-- \treturn \t}  \tfor pn := s.head; pn != nil; { \tif pn.next == n { \tpn.next = n.next  \tif n == s.tail { \ts.tail = pn \t}  \tbreak \t}  \tpn = pn.next \t}  \ts.length-- } Deleting front node of the linked list costs O(1).\nJust set your head node to current head node\u0026rsquo;s next node.\nHowever deleting node at the back costs O(N).\nBecause you don\u0026rsquo;t know current tail node\u0026rsquo;s previous node. (which is going to be a new tail node)\nYou have to traverse all the way to tail node\u0026rsquo;s previous node.\nThen delete tail node and set tail node\u0026rsquo;s previous node to tail. Deleting specific node also costs O(N). You don\u0026rsquo;t know node\u0026rsquo;s previous node, so you have to traverse to find previous node.\nSingly Linked List Time Complexity  Insert at head: O(1) Insert at tail: O(1) Insert at index: O(N) Remove at head: O(1) Remove at tail: O(N) Remove at index: O(N) Search: O(N)  There is improved linked list called Doubly Linked List.\nWe will talk about that in the next post.\nReferences  https://www.geeksforgeeks.org/data-structures/linked-list/ https://www.programiz.com/dsa/linked-list  ","permalink":"https://go-qkbell.github.io/posts/data_structure/linked_list/","summary":"What is linked list","title":"[DataStructure] Singly Linked List"},{"content":"갑자기 든 생각인데, 취직하고 나서는 딱히 개인 프로젝트를 진행한 것도 없고 주말에 한 시간 이상 코딩을 해본적도 없는 것 같다.\n취준 할 당시만 해도, 취직하고 나서도 계속 자기개발을 해서 진취적인 개발자가 되겠다고 다짐했던거 같은데\u0026hellip; ㅋㅋ\n딱히 게임을 많이 하는 것도 아니고, 해봤자 주말에 에이펙스 한두시간 하고 안하는편인데\n왜이럴까 생각해보니, 요즘 버튜버에 빠져 있어서 하루종일 유튜브만 보는 것 같다.\n이왕 보는거 코딩도 하면서 보려고 내가 좋아하는 취미랑 연관도 있고 학습도 할 겸 홀로라이브 디스코드 봇을 제작해보려고 한다.\n현재 생각중인 핵심 기능으로는\n 현재 라이브 방송 중인 모든 홀로라이브 멤버를 알려주는 기능  채널명, 채널 링크, 썸네일 사진, 시청자수   라이브 방송 예정인 홀로라이브 멤버들을 알려주는 기능  채널명, 채널 링크, 썸네일 사진, 시작 예정 시간   홀로라이브 멤버가 새 영상을 유튜브에 올리면 알림 해주는 기능 홀로라이브 멤버 정보를 출력 해주는 기능  이렇게 4 가지가 있다. 나머지는 개발하면서 생각 나면 실시간으로 추가하는걸로.. 필요한 작업 으로는\n 디스코드 연동 유튜브 연동 홀로라이브 데이터 폴링 혹은 pubsub 구독 만약 폴링 구조로 갈 시, 홀로라이브 데이터 일정 시간동안 캐싱  등이 있는 것 같다. 인프라는 구글 클라우드 vm 인스턴스랑 cloud run 중에 고민중이다.\n어차피 이걸로 대형 디스코드 서버를 운영할 생각도 없고, 그냥 개인 서버에서 친구들이랑 쓸 용도라 cloud run 프리티어로 굴리면서 서버리스로 가도 될 것 같은데..\n우선 이부분은 어느정도 개발을 끝마치고 생각해 봐야겠다.\n오랜만에 재밌어보이는 프로젝트라 기대된다.\n","permalink":"https://go-qkbell.github.io/posts/study/hololive1/","summary":"홀로라이브 디스코드 봇 제작기","title":"[Study] Hololive Discord Bot 제작기 #1"},{"content":"What is Array?  Array is a collection of data stored in physically contiguous memory. Array is fixed size. Once the size is given to it, it cannot be changed. Elements must be same type.  Initialize Array package main  import \u0026#34;fmt\u0026#34;  func main() { \tvar s [4]int // initialize int type array with length 4.  \tfmt.Println(s) // [0 0 0 0] } You can define length of array like [4]T.\nLength of array is defined at compile time. So it cannot be changed.\nMemory Alignment package main  import ( \t\u0026#34;fmt\u0026#34; \t\u0026#34;unsafe\u0026#34; )  func main() { \ts := [4]int{10, 20, 30, 40} \tfmt.Printf(\u0026#34;%p, %p, %p, %p\\n\u0026#34;, \u0026amp;s[0], \u0026amp;s[1], \u0026amp;s[2], \u0026amp;s[3]) // 0xc000102000, 0xc000102008, 0xc000102010, 0xc000102018 \tfmt.Println(unsafe.Sizeof(s)) // total size is 8 x 4 = 32 bytes } Array is contiguous memory.\nEach element in array s is int. Int is 8 bytes in 64 bits architecture.\nCalculate the position of each element by simply adding an offset to a base value.\nYou can see address of elements are increasing by 8.\nAccess Array by Index package main  import ( \t\u0026#34;fmt\u0026#34; )  func main() { \ts := [4]int{10, 20, 30, 40} \tfmt.Println(s[0]) // 10 } Array has advantage in random access. It uses index to access the specific element.\nNo matter how long the array is, if you use index, it always costs O(1).\nArray has good cache locality too.\nSince it is stored in contiguous memory, there is less chance of cache miss.\nBut since it has fixed size, it is a bit inflexible, so array is not often seen in Go code.\nHowever, we see slices everywhere.\nWhat is Slice?  Slice is a dynamic array. Unlike array, slice\u0026rsquo;s size can be changed during runtime.  Initialize Slice package main  import ( \t\u0026#34;fmt\u0026#34; )  func main() { \ts := []int{10, 20, 30, 40} // method one \tt := make([]int, 5) // method two \tfmt.Println(s) // [10 20 30 40] \tfmt.Println(t) // [0 0 0 0 0] } There are two ways to initialize slice.\nOne is same as initializing array, but without any length. Like []T.\nSecond is by using built-in function called \u0026ldquo;make\u0026rdquo;.\nfunc make([]T, len, cap) []T\nmake function takes a type, a length, and an optional capacity.\nAccess Slice by Index package main  import ( \t\u0026#34;fmt\u0026#34; )  func main() { \ts := []int{10, 20, 30, 40} \tfmt.Println(s[0]) // 10 } Slice just works like array.\nBecause\u0026hellip;\nSlice Internal Slice is just data structure that points to its underlying array.\nIt consists of a pointer to the array, the length of the slice, and capacity.\npackage main  import \u0026#34;fmt\u0026#34;  func main() { \ts := make([]byte, 5) \tfmt.Println(s) // [0 0 0 0 0] } This is how slice of bytes looks like under layer.\nSlice pointer is pointing to its underlying array.\nSlice has length of 5 and capacity of 5.\nSlice Append package main  import \u0026#34;fmt\u0026#34;  func main() { \ts := make([]int, 5) \tt := make([]int, 5, 6)  \tfmt.Println(len(s), cap(s)) // 5 5 \tfmt.Println(len(t), cap(t)) // 5 6  \tfmt.Printf(\u0026#34;%p\\n\u0026#34;, s) // 0xc00018a000 \tfmt.Printf(\u0026#34;%p\\n\u0026#34;, t) // 0xc00018a030  \t// append data  \ts = append(s, 1) \tt = append(t, 1)  \tfmt.Println(len(s), cap(s)) // 6 10 \tfmt.Println(len(t), cap(t)) // 6 6  \tfmt.Printf(\u0026#34;%p\\n\u0026#34;, s) // 0xc000194000 \tfmt.Printf(\u0026#34;%p\\n\u0026#34;, t) // 0xc00018a030 } When adding element to the back of slice, if slice has free capacity, then it costs O(1).\nYou just have to push into the free space.\nHowever if capacity does not have any free space, then the magic happens.\nSince array is fixed size and cannot be changed, slice copies its underlying array then make another new array with bigger size. (usually doubles)\nThen paste old data into new array and points to it.\nThis costs O(N) because you have to copy N times.\npackage main  import \u0026#34;fmt\u0026#34;  func main() { \ts := make([]int, 5) \tt := make([]int, 5, 10)  \tfmt.Println(len(s), cap(s)) // 5 5 \tfmt.Println(len(t), cap(t)) // 5 10  \tfmt.Printf(\u0026#34;%p\\n\u0026#34;, s) // 0xc00018a000 \tfmt.Printf(\u0026#34;%p\\n\u0026#34;, t) // 0xc00018a030  \t// append data  \ts = append(s[:4], s[3:]...) // append to make replace spot \tt = append(t[:4], t[3:]...) // append to make replace spot \ts[3] = 100 // change \tt[3] = 100 // change  \tfmt.Println(len(s), cap(s)) // 6 10 \tfmt.Println(len(t), cap(t)) // 6 10  \tfmt.Printf(\u0026#34;%p\\n\u0026#34;, s) // 0xc000194000 \tfmt.Printf(\u0026#34;%p\\n\u0026#34;, t) // 0xc00018a030  \tfmt.Println(s) // [0 0 0 100 0 0] \tfmt.Println(t) // [0 0 0 100 0 0] } Now let\u0026rsquo;s try to add to the middle.\nIt looks same as appending to last. But it\u0026rsquo;s not.\nEven though you have enough capacity and did not make new underlying array, you appended to make replace spot.\nSo it is O(N).\nSlice Remove package main  import \u0026#34;fmt\u0026#34;  func main() { \ts := []int{1,2,3,4,5}  \ts = append(s[:2], s[3:]...) // append to delete index 2  \tfmt.Println(s) // [1 2 4 5] } When removing, element from first and last index is O(1).\nBecause you just move around length pointer.\nBut removing element in the middle needs append and costs O(N).\nNil Slice package main  import \u0026#34;fmt\u0026#34;  func main() { \tvar a []int \tvar b []int = make([]int, 0) \tvar c []int = []int{}  \tfmt.Println(a, b, c) // [] [] [] \tfmt.Println(a == nil) // true \tfmt.Println(b == nil) // false \tfmt.Println(c == nil) // false } Nil slice means, slice does not have memory address.\nB and C slices are initialized with 0 length underlying array, and have memory address.\nHowever, A slice is just declared and is not initialized. (A does not have underlying array)\nAll 3 of them have 0 length, but they are not same.\nYou have to be careful dealing with nil slice and empty slice.\nSlice Time Complexity only worst cases\n Insert at head: O(N) Insert at tail: O(N) Insert at index: O(N) Remove at head: O(1) Remove at tail: O(1) Remove at index: O(N) Search: O(1)  References  https://go.dev/blog/slices-intro https://en.wikipedia.org/wiki/Locality_of_reference https://www.geeksforgeeks.org/introduction-to-arrays  ","permalink":"https://go-qkbell.github.io/posts/data_structure/array_slice/","summary":"What are array and slice","title":"[DataStructure] Array \u0026 Slice"},{"content":"내가 공부할 때 사용하는 사이트들 KR  https://ultimate-go-korean.gitbook.io/book/ https://miryang.gitbook.io/learn-go-with-tests/ http://pyrasis.com/go.html  EN  https://research.swtch.com/ https://go101.org/article/101.html https://github.com/golang/go/wiki/CommonMistakes https://github.com/uber-go/guide/blob/master/style.md https://go.dev/tour/welcome/1 https://www.reddit.com/r/golang/  ","permalink":"https://go-qkbell.github.io/posts/study/go_study/","summary":"Go 한국어/영어 자료 모음","title":"[Study] Go 한국어/영어 자료 모음"},{"content":"Why I started I usually search in google or stackoverflow when I\u0026rsquo;m stuck while coding.\nSometimes their answers lead me to third-party blogs.\nWhen I find informative answers I really thank the author.\nAlso, they motivate me to write posts like them.\nI\u0026rsquo;m not a perfect programmer, but I think it will be great if I can share my knowledge and experience with others and get some feedbacks.\nWhat Contents? I will be posting about things I\u0026rsquo;ve studied, experienced and how I solved them. ✍\nWhen to post? I will be posting once a week.\n","permalink":"https://go-qkbell.github.io/posts/blog/first/","summary":"I\u0026rsquo;m starting my Devlog","title":"[README] Starting Devlog"}]